#!/usr/bin/env ruby
# frozen_string_literal: true

# Demo script for eluent - exercises all available features
# Run from project root: bin/demo

require 'fileutils'
require 'json'
require 'securerandom'

# Setup paths
PROJECT_ROOT = Pathname.new(__dir__).parent
DEMO_DIR = PROJECT_ROOT / 'tmp' / 'demo'
EL_CMD = "bundle exec ruby #{PROJECT_ROOT / 'exe' / 'el'}".freeze

# Helper to run el commands
def el(args, capture: false, show_output: true)
  cmd = "cd #{DEMO_DIR} && #{EL_CMD} #{args}"
  puts "\n\e[36m$ el #{args}\e[0m" if show_output

  if capture
    output = `#{cmd} 2>&1`
    puts output if show_output
    output
  else
    system(cmd)
  end
end

def section(title)
  puts "\n\e[33m#{'=' * 60}\e[0m"
  puts "\e[33m#{title}\e[0m"
  puts "\e[33m#{'=' * 60}\e[0m"
end

def step(description)
  puts "\n\e[32m>> #{description}\e[0m"
end

# Clean up and create demo directory
section 'SETUP'
step "Creating fresh demo directory at #{DEMO_DIR}"
FileUtils.rm_rf(DEMO_DIR)
FileUtils.mkdir_p(DEMO_DIR)

# Initialize git (required for el init)
step 'Initializing git repository'
system("cd #{DEMO_DIR} && git init -q")

# ============================================================
section '1. INITIALIZE REPOSITORY'
# ============================================================

step 'Initialize eluent repository'
el 'init --name demo-project'

step 'Show current config'
el 'config show'

# ============================================================
section '2. CREATE ATOMS (Work Items)'
# ============================================================

step 'Create a feature with high priority'
output = el "create -t 'User authentication system' " \
            "-d 'Implement login, logout, and session management' --type feature -p 1",
            capture: true
feature_id = output[/Created \w+ (\w+):/, 1]
puts "  -> Short ID: #{feature_id}"

step 'Create a bug report'
output = el "create -t 'Login button unresponsive on mobile' " \
            "-d 'Users report the login button does not respond on iOS Safari' --type bug -p 2",
            capture: true
bug_id = output[/Created \w+ (\w+):/, 1]
puts "  -> Short ID: #{bug_id}"

step 'Create several tasks'
output = el "create -t 'Design database schema' --type task -p 2 -l backend -l database", capture: true
task1_id = output[/Created \w+ (\w+):/, 1]
puts "  -> task1 ID: #{task1_id}"

output = el "create -t 'Write API endpoints' --type task -p 3 -l backend -l api", capture: true
task2_id = output[/Created \w+ (\w+):/, 1]
puts "  -> task2 ID: #{task2_id}"

output = el "create -t 'Create login form UI' --type task -p 3 -l frontend -l ui", capture: true
task3_id = output[/Created \w+ (\w+):/, 1]
puts "  -> task3 ID: #{task3_id}"

output = el "create -t 'Write unit tests' --type task -p 4 -l testing", capture: true
task4_id = output[/Created \w+ (\w+):/, 1]
puts "  -> task4 ID: #{task4_id}"

step 'Create an epic to group related work'
output = el "create -t 'Q1 Authentication Milestone' --type epic -p 0", capture: true
epic_id = output[/Created \w+ (\w+):/, 1]
puts "  -> epic ID: #{epic_id}"

step 'Create an ephemeral task (local-only, not synced)'
output = el "create -t 'Local debugging notes' --type task -e", capture: true
ephemeral_id = output[/Created \w+ (\w+):/, 1]
puts "  -> ephemeral ID: #{ephemeral_id}"

# ============================================================
section '3. LIST ATOMS'
# ============================================================

step 'List all open items'
el 'list'

step 'List only bugs'
el 'list --type bug'

step 'List by label (backend)'
el 'list -l backend'

step 'List high priority items (0-2)'
el 'list -p 2'

step 'List ephemeral items'
el 'list -e'

# ============================================================
section '4. SHOW ATOM DETAILS'
# ============================================================

step 'Show feature details'
el "show #{feature_id}"

step 'Show feature with verbose output'
el "show #{feature_id} -v"

# ============================================================
section '5. CREATE DEPENDENCIES (Bonds)'
# ============================================================

step 'Create blocking dependencies (task1 blocks task2)'
el "create -t 'Setup CI/CD pipeline' --type task -b #{task1_id}", capture: true

step 'Show dependencies on the feature'
el "show #{feature_id} -d"

# ============================================================
section '6. ADD COMMENTS (CLI)'
# ============================================================

step 'Add comments to the bug report'
el "comment add #{bug_id} 'I can reproduce this on iOS 17.2' --author developer"
el "comment add #{bug_id} 'Also affects iPad Safari' --author qa-team"
el "comment add #{bug_id} 'Root cause: CSS touch-action property missing' --author developer"

step 'List comments on the bug'
el "comment list #{bug_id}"

step 'Show bug with comments (alternative view)'
el "show #{bug_id} -c"

# ============================================================
section '7. UPDATE ATOMS'
# ============================================================

step 'Update task status to in_progress'
el "update #{task1_id} -s in_progress"

step 'Add labels to existing task'
el "update #{task2_id} -l urgent -l sprint-1"

step 'Assign a task'
el "update #{task3_id} -a alice"

step 'Update priority'
el "update #{task4_id} -p 2"

step 'Defer a task until next week'
next_week = (Time.now + (7 * 24 * 60 * 60)).strftime('%Y-%m-%d')
el "update #{task4_id} --defer-until #{next_week}"

step 'List to see updates'
el 'list'

# ============================================================
section '8. CLOSE AND REOPEN'
# ============================================================

step 'Close the bug with a reason'
el "close #{bug_id} -r 'Fixed in commit abc123'"

step 'Show closed bug'
el "show #{bug_id}"

step 'List all (including closed)'
el 'list --all'

step 'Reopen the bug (found regression)'
el "reopen #{bug_id}"

step 'Show reopened bug'
el "show #{bug_id}"

# ============================================================
section '9. CONFIGURATION'
# ============================================================

step 'Show current config'
el 'config show'

step 'Set default priority'
el 'config set defaults.priority 3'

step 'Get specific config value'
el 'config get defaults.priority'

step 'Show updated config'
el 'config show'

# ============================================================
section '10. PERSIST EPHEMERAL'
# ============================================================

step 'Show ephemeral items before persisting'
el 'list -e'

step 'Persist ephemeral task'
el "update #{ephemeral_id} --persist"

step 'Ephemeral list should be empty now'
el 'list -e'

step 'Task should appear in regular list'
el 'list'

# ============================================================
section '11. ROBOT MODE (JSON OUTPUT)'
# ============================================================

step 'List in robot mode (machine-readable JSON)'
el 'list --robot'

step 'Show in robot mode'
el "show #{feature_id} --robot"

# ============================================================
section '12. DEPENDENCY MANAGEMENT'
# ============================================================

step 'Add dependency: task1 must complete before task2'
el "dep add #{task1_id} #{task2_id}"

step 'Add dependency: task2 must complete before task3'
el "dep add #{task2_id} #{task3_id}"

step 'List dependencies for task2 (shows incoming and outgoing)'
el "dep list #{task2_id}"

step 'Show dependency tree from task1'
el "dep tree #{task1_id}"

step 'Show blocking-only dependency tree'
el "dep tree #{task1_id} -b"

step 'Run dependency health check'
el 'dep check'

step 'Try to create a cycle (should fail)'
el "dep add #{task3_id} #{task1_id}"

step 'Remove a dependency'
el "dep remove #{task2_id} #{task3_id}"

step 'Verify dependency removed'
el "dep list #{task2_id}"

# ============================================================
section '13. READY QUEUE (Actionable Items)'
# ============================================================

step 'Show items ready for work (unblocked, not deferred)'
el 'ready'

step 'Show ready items sorted by oldest first (prevents starvation)'
el 'ready --sort oldest'

step 'Show ready items with hybrid sorting (balances priority and age)'
el 'ready --sort hybrid'

step 'Show ready bugs only'
el 'ready --type bug'

step 'Show ready items assigned to alice'
el 'ready --assignee alice'

step 'Show ready items with backend label'
el 'ready -l backend'

step 'Show ready items excluding epics'
el 'ready --exclude epic'

step 'Ready queue in robot mode'
el 'ready --robot'

# ============================================================
section '14. SOFT DELETE (Discard/Restore)'
# ============================================================

step 'Create a task we will discard'
output = el "create -t 'Temporary investigation task' --type task", capture: true
temp_id = output[/Created \w+ (\w+):/, 1]
puts "  -> temp ID: #{temp_id}"

step 'Discard the temporary task (soft delete)'
el "discard #{temp_id}"

step 'List discarded items'
el 'discard list'

step 'Show the discarded item (still accessible)'
el "show #{temp_id}"

step 'Restore the discarded item'
el "discard restore #{temp_id}"

step 'Discarded list should be empty now'
el 'discard list'

step 'Item is back in regular list'
el "show #{temp_id}"

step 'Discard it again for prune demo'
el "discard #{temp_id}"

step 'Prune discarded items (permanently delete)'
el 'discard prune --days 0 --force'

# ============================================================
section '15. FORMULAS (Reusable Work Templates)'
# ============================================================

step 'Create formula directory and sample formulas'
formulas_dir = DEMO_DIR / '.eluent' / 'formulas'
FileUtils.mkdir_p(formulas_dir)

# Create a sprint planning formula
File.write(formulas_dir / 'sprint-planning.yaml', <<~YAML)
  id: sprint-planning
  title: Sprint Planning for {{feature}}
  description: Standard sprint workflow for implementing a feature
  variables:
    feature:
      description: Name of the feature
      required: true
    assignee:
      description: Primary developer
      default: unassigned
    sprint:
      description: Sprint identifier
      default: current
  steps:
    - id: design
      title: Design {{feature}}
      issue_type: task
      labels:
        - design
        - sprint-{{sprint}}
    - id: implement
      title: Implement {{feature}}
      issue_type: task
      assignee: "{{assignee}}"
      depends_on:
        - design
      labels:
        - backend
        - sprint-{{sprint}}
    - id: test
      title: Test {{feature}}
      issue_type: task
      depends_on:
        - implement
      labels:
        - testing
        - sprint-{{sprint}}
    - id: review
      title: Code review for {{feature}}
      issue_type: task
      depends_on:
        - implement
      labels:
        - review
        - sprint-{{sprint}}
YAML

# Create a bug fix formula
File.write(formulas_dir / 'bug-fix.yaml', <<~YAML)
  id: bug-fix
  title: Bug Fix Workflow
  description: Standard bug investigation and fix process
  variables:
    bug_title:
      description: Brief bug description
      required: true
    severity:
      description: Bug severity level
      enum:
        - low
        - medium
        - high
        - critical
      default: medium
  steps:
    - id: investigate
      title: Investigate {{bug_title}}
      issue_type: task
      priority: 1
      labels:
        - investigation
    - id: fix
      title: Fix {{bug_title}}
      issue_type: task
      depends_on:
        - investigate
      labels:
        - fix
        - severity-{{severity}}
    - id: verify
      title: Verify fix for {{bug_title}}
      issue_type: task
      depends_on:
        - fix
      labels:
        - verification
YAML

step 'List available formulas'
el 'formula list'

step 'Show sprint-planning formula details'
el 'formula show sprint-planning'

step 'Instantiate sprint-planning formula with variables'
output = el 'formula instantiate sprint-planning --var feature=OAuth --var assignee=bob --var sprint=Q1',
            capture: true
# Capture the epic ID from the output for later use in distill
output[/root_atom_id['":\s]+([^'",\s}]+)/, 1] ||
  (output[/Created (\d+) items/, 1] && 'OAuth') # fallback
puts '  -> Created items from template'

step 'List items to see the created hierarchy'
el 'list'

step 'Instantiate bug-fix formula for a security issue'
el "formula instantiate bug-fix --var bug_title='XSS vulnerability' --var severity=critical",
   capture: true

step 'Distill a formula from the OAuth epic (has child items from instantiation)'
# Use robot mode to get the epic ID, then distill from it
oauth_list = el 'list --type epic --robot', capture: true, show_output: false
begin
  oauth_data = JSON.parse(oauth_list)
  # Robot mode uses 'items' key for the list
  oauth_epic = oauth_data.dig('data', 'items')&.find { |a| a['title']&.include?('Sprint Planning for OAuth') }
  if oauth_epic
    # Use the full ID - the CLI can resolve it
    full_id = oauth_epic['id']
    puts "  -> Found OAuth epic: #{full_id.split('-').last[0, 8]}..."
    el "formula distill #{full_id} --id oauth-workflow --extract 'OAuth=feature_name'"
  else
    puts '  -> Could not find OAuth epic in list'
  end
rescue JSON::ParserError => e
  puts "  -> JSON parse error: #{e.message[0, 50]}"
end

step 'List formulas to see the newly distilled formula'
el 'formula list'

step 'Show the distilled formula'
el 'formula show oauth-workflow'

step 'Compose formulas: combine bug-fix and sprint-planning sequentially'
el 'formula compose bug-fix sprint-planning --id full-cycle --type sequential --title "Full Development Cycle"',
   capture: true

step 'Show the composed formula'
el 'formula show full-cycle'

step 'Attach a formula to an existing epic'
el "formula attach bug-fix #{epic_id} --var bug_title='Performance regression' --var severity=high",
   capture: true

step 'Show epic with attached formula items'
el "show #{epic_id} -d"

step 'Formula commands in robot mode'
el 'formula list --robot'

# ============================================================
section '16. COMPACTION (Archive Old Items)'
# ============================================================

step 'Create an old closed item for compaction demo'
# Create a new task and close it, then backdate it
desc = "This was an old task with a #{'detailed ' * 50}description that should be compacted."
output = el "create -t 'Legacy cleanup task' -d '#{desc}' --type task", capture: true
old_task_id = output[/Created \w+ (\w+):/, 1]
puts "  -> Created task: #{old_task_id}"

# Close the task
el "close #{old_task_id} -r 'Completed long ago'"

# Now backdate the closed task in the data file
old_time = (Time.now - (45 * 24 * 60 * 60)).utc.iso8601
data_file = DEMO_DIR / '.eluent' / 'data.jsonl'
content = File.read(data_file)
lines = content.lines.map do |line|
  data = begin
    JSON.parse(line, symbolize_names: true)
  rescue StandardError
    nil
  end
  if data && data[:_type] == 'atom' && data[:title] == 'Legacy cleanup task'
    # Backdate the closed task to simulate an old item
    data[:closed_at] = old_time
    data[:updated_at] = old_time
    data[:created_at] = old_time
    "#{JSON.generate(data)}\n"
  else
    line
  end
end
File.write(data_file, lines.join)
puts '  -> Backdated closed task to 45 days ago'

step 'Preview tier 1 compaction (items > 30 days old)'
el 'compact run --tier 1 --preview'

step 'Run tier 1 compaction'
el 'compact run --tier 1'

step 'Preview tier 2 compaction (items > 90 days old)'
el 'compact run --tier 2 --preview'

step 'Show compaction help'
el 'compact --help'

# ============================================================
section '17. PLUGINS (Extensibility)'
# ============================================================

step 'List loaded plugins (none by default)'
el 'plugin list'

step 'Show registered hooks (empty)'
el 'plugin hooks'

step 'Create a sample plugin that validates priority'
plugins_dir = DEMO_DIR / '.eluent' / 'plugins'
FileUtils.mkdir_p(plugins_dir)

File.write(plugins_dir / 'priority_validator.rb', <<~RUBY)
  # frozen_string_literal: true

  # Example plugin: validates that high-priority items have descriptions
  # Hooks are invoked when integrated at the application layer
  Eluent::Plugins.register 'priority-validator' do
    # Run before creating any item (priority 50 = runs early)
    before_create(priority: 50) do |ctx|
      item = ctx.item
      # Require description for priority 0-1 items
      if item.priority && item.priority <= 1 && (item.description.nil? || item.description.empty?)
        ctx.halt!('High-priority items (0-1) must have a description')
      end
    end

    # Log after items are created
    after_create do |ctx|
      puts "  [priority-validator] Created: \#{ctx.item.title}"
    end
  end
RUBY

step 'Create a notification plugin'
File.write(plugins_dir / 'notifier.rb', <<~RUBY)
  # frozen_string_literal: true

  # Example plugin: logs notifications on status changes
  Eluent::Plugins.register 'notifier' do
    # Track status changes (priority 100 = default)
    on_status_change(priority: 100) do |ctx|
      old_status = ctx.changes[:old_status]
      new_status = ctx.changes[:new_status]
      puts "  [notifier] Status: \#{old_status} -> \#{new_status}"
    end

    # Track closed items
    after_close do |ctx|
      puts "  [notifier] Closed: \#{ctx.item.title}"
    end

    # Sync notifications
    on_sync do |ctx|
      puts "  [notifier] Sync completed"
    end
  end
RUBY

step 'List plugins (now shows our custom plugins)'
el 'plugin list'

step 'Show registered hooks (now populated)'
el 'plugin hooks'

step 'Plugin list in robot mode'
el 'plugin list --robot'

step 'Hooks in robot mode'
el 'plugin hooks --robot'

# ============================================================
section '18. AI AGENT INTEGRATION (Library Demo)'
# ============================================================

puts <<~MSG

  \e[33mNote: The AI Agent system is a library feature, not a CLI command.\e[0m
  It provides programmatic integration with Claude and OpenAI APIs.

  \e[36mKey components:\e[0m
  - AgentExecutor: Abstract base for AI integrations
  - ClaudeExecutor: Claude API implementation
  - OpenAIExecutor: OpenAI API implementation
  - ExecutionLoop: Automated work processing loop

  \e[36mAvailable tools for agents:\e[0m
  - list_items: Query items with filters
  - show_item: Get item details
  - create_item: Create new items
  - update_item: Modify existing items
  - close_item: Complete work items
  - list_ready_items: Find actionable work
  - add_dependency: Create relationships
  - add_comment: Add discussion

  \e[36mExample usage (Ruby):\e[0m

    config = Eluent::Agents::Configuration.new(
      provider: :claude,
      api_key: ENV['ANTHROPIC_API_KEY'],
      agent_id: 'agent-001'
    )

    executor = Eluent::Agents::ClaudeExecutor.new(
      repository: repo,
      configuration: config
    )

    loop = Eluent::Agents::ExecutionLoop.new(
      repository: repo,
      executor: executor,
      configuration: config
    )

    # Process up to 5 ready items
    result = loop.run(max_iterations: 5)
    puts result.summary

MSG

# ============================================================
section '19. LEDGER SYNC SETUP'
# ============================================================

puts <<~MSG

  \e[33mNote: Ledger Sync enables multi-agent coordination via an orphan branch.\e[0m
  It provides atomic claims so multiple agents can safely share work without races.

MSG

step 'Create a bare remote repository (simulating remote server)'
REMOTE_REPO = DEMO_DIR.parent / 'demo-remote.git'
FileUtils.rm_rf(REMOTE_REPO)
system("git init --bare #{REMOTE_REPO} -q")
puts "  -> Created bare repo at #{REMOTE_REPO}"

step 'Add remote to the demo repository'
system("cd #{DEMO_DIR} && git remote add origin #{REMOTE_REPO}")

step 'Make initial commit and push to establish remote tracking'
system("cd #{DEMO_DIR} && git add -A && git commit -m 'Initial eluent setup' -q")
system("cd #{DEMO_DIR} && git branch -M main && git push -u origin main -q 2>&1")

step 'Configure ledger sync branch in config'
el 'config set sync.ledger_branch eluent-sync'

step 'Show sync configuration'
el 'config get sync.ledger_branch'

step 'Initialize ledger sync (creates orphan branch and worktree)'
el 'sync --setup-ledger'

step 'Show ledger sync status'
el 'sync --status'

# ============================================================
section '20. ATOMIC CLAIMS'
# ============================================================

step 'Claim a task atomically (with ledger sync)'
el "claim #{task1_id} --agent-id agent-alpha"

step 'Show the claimed task (notice assignee and in_progress status)'
el "show #{task1_id}"

step 'Try to claim an already-claimed task (will fail with CLAIM_CONFLICT)'
el "claim #{task1_id} --agent-id agent-beta"

step 'Force-claim to steal from another agent'
el "claim #{task1_id} --agent-id agent-beta --force"

step 'Show task now assigned to agent-beta'
el "show #{task1_id}"

step 'Claim with default agent ID (uses hostname)'
el "claim #{task2_id}"

step 'Claim in quiet mode (for scripting)'
el "claim #{task3_id} --agent-id scripted-agent --quiet"
puts '  -> (quiet mode produces no output on success)'

step 'List in-progress items (shows claimed work)'
el 'list -s in_progress'

step 'Claim command in robot mode'
el "claim #{task4_id} --agent-id robot-agent --robot"

# ============================================================
section '21. LEDGER-ONLY SYNC (Fast)'
# ============================================================

step 'Perform ledger-only sync (syncs only .eluent/, faster than full sync)'
el 'sync --ledger-only'

step 'Check sync status after ledger sync'
el 'sync --status'

step 'Standard sync (includes both code and ledger)'
el 'sync'

# ============================================================
section '22. OFFLINE MODE WITH RECONCILIATION'
# ============================================================

step 'Create a new task for offline demo'
output = el "create -t 'Offline mode test task' --type task", capture: true
offline_task_id = output[/Created \w+ (\w+):/, 1]
puts "  -> task ID: #{offline_task_id}"

step 'Claim an item in offline mode (local-only, queued for later sync)'
el "claim #{offline_task_id} --agent-id offline-agent --offline"

step 'Check sync status (shows pending offline claim)'
el 'sync --status'

step 'Reconcile offline claims (push pending claims to remote)'
el 'sync --reconcile'

step 'Verify reconciliation complete (no pending claims)'
el 'sync --status'

# ============================================================
section '23. CLAIM EXIT CODES'
# ============================================================

puts <<~MSG

  \e[33mClaim command uses specific exit codes for scripting:\e[0m
    0 - SUCCESS: Claim successful
    1 - CLAIM_CONFLICT: Already claimed by another agent
    2 - CLAIM_RETRIES: Max retries exhausted (persistent conflict)
    3 - LEDGER_NOT_CONFIGURED: Ledger sync not available
    4 - ATOM_NOT_FOUND: Atom does not exist
    5 - ATOM_TERMINAL: Cannot claim closed/discarded atom

MSG

step 'Try to claim a closed atom (exit code 5)'
# Close an atom first
el "close #{offline_task_id} -r 'Completed'"
el "claim #{offline_task_id} --agent-id test-agent"
puts "  -> Exit code indicates atom is in terminal state"

step 'Try to claim a non-existent atom (exit code 4)'
el 'claim NOTEXIST --agent-id test-agent'
puts "  -> Exit code indicates atom not found"

# ============================================================
section '24. LEDGER CLEANUP'
# ============================================================

step 'Clean up ledger sync infrastructure'
el 'sync --cleanup-ledger --yes'

step 'Verify ledger is disabled'
el 'sync --status'

step 'Claims now fall back to local-only mode'
output = el "create -t 'Post-cleanup task' --type task", capture: true
post_cleanup_id = output[/Created \w+ (\w+):/, 1]
el "claim #{post_cleanup_id} --agent-id local-agent"

# ============================================================
section 'SUMMARY'
# ============================================================

puts "\n\e[35mDemo completed successfully!\e[0m"
puts "\nData stored in: #{DEMO_DIR}/.eluent/"
puts "\nFiles created:"
Dir.glob("#{DEMO_DIR}/.eluent/*").each do |f|
  if File.directory?(f)
    puts "  #{File.basename(f)}/ (directory)"
  else
    puts "  #{File.basename(f)} (#{File.size(f)} bytes)"
  end
end

puts "\n\e[35mPlugins directory:\e[0m"
Dir.glob("#{DEMO_DIR}/.eluent/plugins/*").each do |f|
  puts "  #{File.basename(f)}"
end

puts "\n\e[35mFormulas directory:\e[0m"
Dir.glob("#{DEMO_DIR}/.eluent/formulas/*").each do |f|
  puts "  #{File.basename(f)}"
end

puts "\n\e[35mRemote repository (simulated):\e[0m"
puts "  #{REMOTE_REPO}"

puts "\n\e[35mData file contents:\e[0m"
data_file = DEMO_DIR / '.eluent' / 'data.jsonl'
File.readlines(data_file).each do |line|
  data = JSON.parse(line, symbolize_names: true)
  case data[:_type]
  when 'header'
    puts "\e[33m[HEADER]\e[0m repo=#{data[:repo_name]}"
  when 'atom'
    puts "\e[32m[ATOM]\e[0m #{data[:id].split('-').last[0, 4]} #{data[:status]} #{data[:issue_type]}: #{data[:title]}"
  when 'bond'
    source = data[:source_id].split('-').last[0, 4]
    target = data[:target_id].split('-').last[0, 4]
    puts "\e[34m[BOND]\e[0m #{source} --#{data[:dependency_type]}--> #{target}"
  when 'comment'
    puts "\e[36m[COMMENT]\e[0m #{data[:author]}: #{data[:content][0, 40]}..."
  end
end

puts "\n\e[35mFeatures demonstrated:\e[0m"
puts '  1-11:  Core atom/bond/comment management'
puts '  12-15: Dependencies, ready queue, soft delete, formulas'
puts '  16-18: Compaction, plugins, AI agent integration'
puts '  19-24: Ledger sync (atomic claims, offline mode, reconciliation)'

puts "\n\e[35mCleaning up remote repository...\e[0m"
FileUtils.rm_rf(REMOTE_REPO)
puts '  -> Removed simulated remote'
